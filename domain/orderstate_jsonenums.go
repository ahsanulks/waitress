// generated by jsonenums -type=OrderState; DO NOT EDIT

package domain

import (
	"encoding/json"
	"fmt"
)

var (
	_OrderStateNameToValue = map[string]OrderState{
		"pending":   Pending,
		"paid":      Paid,
		"accepted":  Accepted,
		"delivered": Delivered,
		"remitted":  Remitted,
		"refunded":  Refunded,
		"rejected":  Rejected,
		"cancelled": Cancelled,
		"expired":   Expired,
	}

	_OrderStateValueToName = map[OrderState]string{
		Pending:   "pending",
		Paid:      "paid",
		Accepted:  "accepted",
		Delivered: "delivered",
		Remitted:  "remitted",
		Refunded:  "refunded",
		Rejected:  "rejected",
		Cancelled: "cancelled",
		Expired:   "expired",
	}
)

// MarshalJSON is generated so OrderState satisfies json.Marshaler.
func (r OrderState) MarshalJSON() ([]byte, error) {
	s, ok := _OrderStateValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid OrderState: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so OrderState satisfies json.Unmarshaler.
func (r *OrderState) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("OrderState should be a string, got %s", data)
	}
	v, ok := _OrderStateNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid OrderState %q", s)
	}
	*r = v
	return nil
}
